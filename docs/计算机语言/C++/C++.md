---
date: 2021-04-15 20:12:30
updated: 2021-04-25 22:57:10
md5: '33fc000beb32222ddc913620bd15ddc8'
---

# C++


## 内存分区

1. **分类**
    1. **栈**：编译器需要时自动分配，不需要时自动清除。通常存放局部变量、函参等
    2. **堆**：程序员以`new`分配、`delete`释放。若没有释放，操作系统在程序结束后回收
    3. **自由存储区**：程序员以`malloc`等分配、`free`释放。类似堆（实际是同一块区）
    4. **全局/静态存储区**：存放全局变量和静态变量
    5. **常量存储区**：存放常量
2. **堆和栈的区别**
    |              |            堆            |                   栈                    |
    | :----------: | :----------------------: | :-------------------------------------: |
    | **管理方式** |        程序员控制        |               编译器控制                |
    | **内存地址** |  不连续（空闲地址链表）  |                  连续                   |
    | **内存大小** |   受限于有效虚存，较大   |              OS预定，较小               |
    |   **碎片**   |            有            |                   无                    |
    | **生长方向** |      向上（高地址）      |             向下（低地址）              |
    | **分配方式** | 动态分配（如malloc函数） | 静（如局部变量）/动（alloca函数）态分配 |
    | **分配效率** |   低。C/C++函数库提供    |           高。计算机底层支持            |

## 左值、右值

1. **左值**：可用取地址运算符&取地址的表达式。位于赋值号左边
2. **右值**：非左值表达式。位于赋值号右边

## 引用

1. **左值引用**
2. **右值引用**
3. **折叠引用**

## const常量

1. 修饰**变量**：`const int a`。值不可变
2. 修饰**指针**
    1. **常指针**：`int* const p`。指向地址不变
    2. **指向常量的指针**：`const int* p`。指向常变量
    3. **指想常量的常指针**：`const int* const p`。指向地址不变且指向常变量

    !> **甄别方法**：从右往左读，“p” → “p is a”，"*" → "pointer to"

3. 修饰**引用**：`const int &a = b`。值不可通过a改

!> 非常量引用不能引用常量对象

4. 修饰**成员函数**：`void foo() const`（类内）。不可修改类中任何数据成员

## static静态

1. 修饰**变量**：`static int a`。存储在静态/全局数据区；初始化可赋值或取默认值
    1. **全局变量**
        1. `main()`运行前就初始化，程序结束才销毁
        2. 整个文件内可见，文件外不可见（即使`extern`）
    2. **局部变量**
        1. *首次*运行到该处时初始化，程序结束才销毁
        2. 多次调用为同一个变量，但作用域仍然局部
    3. **成员变量**
        1. `main()`运行前就初始化，程序结束才销毁
        2. 所有实例共享一个变量
        3. 不需要实例化即可访问
2. 修饰**函数**：
    1. **普通函数**：
        1. 整个文件内可见，文件外不可见（即使`extern`）
    2. **成员函数**
        1. 不需要实例化即可访问
        2. 不能访问非静态成员

## inline内联

1. 相当于把内联函数内容写在调用的地方。目的是减少频繁调用导致的栈内空间枯竭
2. 仅是对编译器的**建议**。若操作复杂（如包含循环、递归、switch）一般不内联
3. 加在**实现（定义）前**，而不是声明前。一般在**头文件**中声明并实现
4. **成员函数默认内联**（虚函数除外）

!> 若在类内声明，在类外实现，则默认不内联

5. 以**代码膨胀**为代价。因为每一处调用都要复制代码
6. **与宏的差别**
    1. 即使有类似函数的形式，但宏只是简单的**文本替换**；而inline会做**类型检查**、自动类型转换
    2. 宏无法操作成员变量；而inline可以
7. **虚函数可内联，但虚函数表现多态性时不能**。因为虚函数多态性表现在运行期，而编译时无法知道运行时调用哪个代码

## volatile

1. 修饰变量类型，表明变量可被编译器未知因素（OS、硬件、其他线程等）改变
2. 作用是告知编译器不应对其优化。即每次访问从内存取值，而不能从CPU寄存器取（编译优化）
3. 可修饰const。如硬件时钟不能被程序改变，故const；但又被程序以外代理改变，故volatile
4. 可修饰指针。一般用于共享指针。和const类似，也分为指向volatile变量的指针，和volatile指针，甄别方法同const

## assert断言

1. 若非真，则终止程序
2. 是**宏**而不是函数
3. 可以定义`NDEBUG`来关闭，但要在`#include<cassert>`之前

```cpp
#define NDEBUG          // 加上这行，则assert不可用
#include <cassert>
assert( p != NULL );
```

## sizeof

1. sizeof(数组) = 整个数组所占空间
2. sizeof(指针) = 指针本身所占空间

## #pragma pack(n)

```cpp
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设为4字节对齐

struct test
{
    ...
};

#pragma pack(pop)   // 恢复对齐状态
```

## 位域

1. 类中可将成员变量定义为位域，形式位`type [member_name] : width ;`
2. 一个位域含指定数量的二进制位
3. 内存分布与机器有关
4. 类型必须是`int`/`unsigned int`/`signed int`
5. 取地址符&不能作用于位域；任何指针无法指向位域

```cpp
struct test
{
    unsigned a : 1;
    unsigned : 4;   // 空域
    unsigned b : 3; // 从下一单元开始存放
} x;
x.a = 1;
x.b = 5;
x.b = ~x.b; // 2
printf("%d %d\n", x.a, x.b);
```

## extern "C"

1. 告知编译器，这部分代码按C语言方式编译和链接

```cpp
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

## struct在C与C++中区别

|                |       C        |                C++                |
| :------------: | :------------: | :-------------------------------: |
|  **成员函数**  |       ×        |                 √                 |
|  **静态成员**  |       ×        |                 √                 |
|  **可否继承**  |       ×        |                 √                 |
| **可否初始化** |       ×        |                 √                 |
|   **访问权**   | public，不可改 | 默认public，可改private/protected |

### C

```c
// 第一种
typedef struct Student {
    int age; 
} S;

// 第二种，与第一种等价
struct Student { 
    int age; 
};
typedef struct Student S;   // S与struct Student等价
void Student(){}    // 并不冲突，在C中Student与struct Student区分

// 第三种
struct { 
    int age; 
} student;  // 此处是变量而不是tag
```

### C++

```cpp
struct Student { 
    int age; 
};
void f(Student x){}  // 在C++中可用Student代替struct Student
void Student(){}   // 此后，Student只代表此函数，与struct Student区分
```

## struct与class在C++中区别

|                        |            struct             |   class    |
| :--------------------: | :---------------------------: | :--------: |
|        **本质**        |        数据结构实现体         | 对象实现体 |
|     **默认访问权**     |            public             |  private   |
|   **默认继承访问权**   |            public             |  private   |
|  **用于定义模板参数**  |               ×               |     √      |
| **可否用大括号初始化** | 仅无构造函数且成员全public时√ |     √      |

!> struct继承class或反过来时，默认继承访问权取决于子类而不是基类。可指明继承方式，如`class B : public A{}；`

## union联合

1. 有多个数据成员，但任意时刻只有一个数据成员有值
2. 某成员赋值后，其他成员变为未定义状态
3. 默认访问权为public
4. 可含有构造/析构函数
5. 不可含有引用类型的成员
6. 不可继承/被继承
7. 不可含有虚函数
8. **匿名union**
    1. 在定义所在作用域可直接访问union成员
    2. 包含protected成员或private成员
    3. 全局匿名union必须static

## explicit显式

1. 修饰**构造函数**，可防止隐式转换和复制初始化
2. 修饰**转换函数**，可防止隐式转换，但*按语境转换*除外

```cpp
struct B
{
    explicit B(int) {}
    explicit operator bool() const { return true; }
};
void doB(B b) {}
int main()
{
    B b1(1);        // OK：直接初始化
    B b2 = 1;       // 错误：被 explicit 修饰构造函数的对象不可以复制初始化
    B b3{ 1 };      // OK：直接列表初始化
    B b4 = { 1 };   // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
    B b5 = (B)1;    // OK：允许 static_cast 的显式转换
    doB(1);         // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b6(b1);    // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b7 = b1;   // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
    bool b8 = static_cast<bool>(b1);    // OK：static_cast 进行直接初始化

    return 0;
}
```

## friend友元

1. **分类**
    1. **友元函数**：声明在类内（加friend）、定义在类外、可直接访问类的私有成员的非成员函数

    !> 友元函数声明在公有、私有部分没有区别

    2. **友元类**：该类的所有成员函数都是另一个类的友元函数
2. **特点**
    1. 友元关系**不可继承**
    2. 友元关系**不可传递**
    3. 友元类的关系是**单向**的，不具有交换性
    4. 削弱封装性

## using

1. **using声明**：`using namespace_name::name;`。引入命名空间的一个成员
2. **using指示**：`using namespace namespace_name;`。引入命名空间的所有成员

## ::（范围解析运算符）

1. **全局作用域符**`::name`
2. **类作用域符**`class_name::name`
3. **命名空间作用域符**`namespace_name::name`

## enum枚举量

1. **定义**:`enum [enumeration name] {enumerator1[=value1], enumerator2[=value2], ...};`
2. **枚举量的类型和取值**：整数。默认第一个枚举量赋值0，其他枚举量取值是前一个取值+1
3. **运算**：只有赋值运算，没有算术运算
4. **赋值**：只能赋值为枚举量符号，而不是整数值
5. **范围**（略）
6. **强枚举类型enum class（C++11）**（略）

## decltype（C++11）

1. `decltype ( expression )`，等价于表达式的数据类型

## 面向对象

### 封装（三种访问控制权）

|                      | public | protected | private |
| :------------------: | :----: | :-------: | :-----: |
|   **对本类/友元**    |   √    |     √     |    √    |
|      **对子类**      |   √    |     √     |    ×    |
| **对外部（调用方）** |   √    |     ×     |    ×    |

### 继承

1. **基类（父类）→ 派生类（子类）**

### 多态

1. **定义**：信息以多种形式显示的能力
2. 以封装和继承为基础
3. **分类**

|      类型      |   表现时期    |             实现             |
| :------------: | :-----------: | :--------------------------: |
|  **重载多态**  |    编译期     |     函数重载、运算符重载     |
| **子类型多态** |    运行期     |            虚函数            |
|  **参数多态**  |    编译期     |       类模板、函数模板       |
|  **强制多态**  | 编译期/运行期 | 基本类型转换、自定义类型转换 |

!> 编译期表现的多态又叫**静态多态（早绑定）**，运行期表现的多态又叫**动态多态（晚绑定）**

### C实现C++类

1. **封装**：使用函数指针把属性与方法封装到结构体中
2. **继承**：结构体嵌套
3. **多态**：父类与子类方法的函数指针不同

## 虚析构函数

## 虚函数与纯虚函数

## 虚函数指针、虚函数表

## 虚继承与虚函数

## 模板类、成员模板、虚函数

## 抽象类、接口类、聚合类

## 内存分配和管理

## delete this？

## 如何定义一个只能在堆（栈）上生成对象的类？

## 智能指针

## 强制类型转换运算符

## 运行时类型信息RTTI

