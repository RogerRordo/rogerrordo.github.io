---
date: 2021-06-05 22:14:29
updated: 2021-06-05 22:14:29
md5: 'a108e658c7dcff2c4f8d64791669d14c'
---

# C++面试

## 内存分区

1. **分类**
    1. **栈**：编译器需要时自动分配，不需要时自动清除。通常存放局部变量、函参等
    2. **堆**：程序员以`new`分配、`delete`释放。若没有释放，操作系统在程序结束后回收
    3. **自由存储区**：程序员以`malloc`等分配、`free`释放。类似堆（实际是同一块区）
    4. **全局/静态存储区**：存放全局变量和静态变量
    5. **常量存储区**：存放常量
2. **堆和栈的区别**
    |              |            堆            |                   栈                    |
    | :----------: | :----------------------: | :-------------------------------------: |
    | **管理方式** |        程序员控制        |               编译器控制                |
    | **内存地址** |  不连续（空闲地址链表）  |                  连续                   |
    | **内存大小** |   受限于有效虚存，较大   |              OS预定，较小               |
    |   **碎片**   |            有            |                   无                    |
    | **生长方向** |      向上（高地址）      |             向下（低地址）              |
    | **分配方式** | 动态分配（如malloc函数） | 静（如局部变量）/动（alloca函数）态分配 |
    | **分配效率** |   低。C/C++函数库提供    |           高。计算机底层支持            |
3. **如何定义一个只能在堆（栈）上生成对象的类？**
    1. **只在堆上**
        1. **方法**：将析构函数设为private
        2. **原因**：当对象使用完后，编译器会调用析构函数来释放栈对象所占空间。因此，编译器在为类对象分配栈空间时，也会先检查类的析构函数的访问性，如果不能访问，则不能在栈上创建对象。
        3. **不可将构造函数设为private的原因**：`new`运算符分为两步：先执行`operator new()`，在堆中分配合适内存；再调用构造函数构造对象，初始化这片内存。但`operator new()`用于分配内存，无法提供构造功能
    2. **只在栈上**
        1. **方法**：将`new`重载为private
        2. **原因**：`new`运算符分为两步……（见“不可将构造函数设为private的原因”）

## 左值、右值

1. **左值**：可用取地址运算符&取地址的表达式。位于赋值号左边
2. **右值**：非左值表达式。位于赋值号右边

## 引用

1. **左值引用**：常规引用，一般表示对象的**身份**，以&表示
2. **右值引用**：必须绑定到右值（临时、待销毁对象）的引用，一般表示对象的**值**，以&&表示
3. **折叠引用**
    1. 不能直接定义引用的引用，但可以通过**类型别名**或**模板**间接定义
    2. **折叠规则**：若任一引用为左值引用，则结果为左值引用，否则为右值引用。故**万能引用**就是`f(T&& a)`

    !> 任何函数内部，对形参的直接使用，都按**左值**进行
    
    3. **完美转发**：`std::forward`，消除上述问题
        1. **核心代码**：`return static_cast<T&&>(a);`
    4. **移动语义**：`std::move()`可以强制将左值引用转为右值引用
    5. **上两者目的**
        1. 消除对象交互时不必要的对象拷贝，节省运算存储资源
        2. 能够更简洁明确地定义泛型函数

## const常量

1. 修饰**变量**：`const int a`。值不可变
2. 修饰**指针**
    1. **常指针**：`int* const p`。指向地址不变
    2. **指向常量的指针**：`const int* p`。指向常变量
    3. **指想常量的常指针**：`const int* const p`。指向地址不变且指向常变量

    !> **甄别方法**：从右往左读，“p” → “p is a”，"*" → "pointer to"

3. 修饰**引用**：`const int &a = b`。值不可通过a改

!> 非常量引用不能引用常量对象

4. 修饰**成员函数**：`void foo() const`（类内）。不可修改类中任何数据成员

## static静态

1. **作用**：**隐藏**、**持久**、**初始为0**、类中的特殊作用
2. 修饰**变量**：`static int a`。存储在静态/全局数据区；初始化可赋值或取默认值
    1. **全局变量**
        1. `main()`运行前就初始化，程序结束才销毁
        2. 整个文件内可见，文件外不可见（即使`extern`）
    2. **局部变量**
        1. *首次*运行到该处时初始化，程序结束才销毁
        2. 多次调用为同一个变量，但作用域仍然局部
    3. **成员变量**
        1. `main()`运行前就初始化，程序结束才销毁
        2. 所有实例共享一个变量
        3. 不需要实例化即可访问
3. 修饰**函数**：
    1. **普通函数**：
        1. 整个文件内可见，文件外不可见（即使`extern`）
    2. **成员函数**
        1. 不需要实例化即可访问
        2. 不能访问非静态成员

## inline内联

1. 相当于把内联函数内容写在调用的地方。目的是减少频繁调用导致的栈内空间枯竭
2. 仅是对编译器的**建议**。若操作复杂（如包含循环、递归、switch）一般不内联
3. 加在**实现（定义）前**，而不是声明前。一般在**头文件**中声明并实现
4. **成员函数默认内联**（虚函数除外）

!> 若在类内声明，在类外实现，则默认不内联

5. 以**代码膨胀**为代价。因为每一处调用都要复制代码
6. **与宏的差别**
    1. 即使有类似函数的形式，但宏只是简单的**文本替换**；而inline会做**类型检查**、自动类型转换
    2. 宏无法操作成员变量；而inline可以
7. **虚函数可内联，但虚函数表现多态性时不能**。因为虚函数多态性表现在运行期，而编译时无法知道运行时调用哪个代码

## volatile

1. 修饰变量类型，表明变量可被编译器未知因素（OS、硬件、其他线程等）改变
2. 作用是告知编译器不应对其优化。即每次访问从内存取值，而不能从CPU寄存器取（编译优化）
3. 可修饰const。如硬件时钟不能被程序改变，故const；但又被程序以外代理改变，故volatile
4. 可修饰指针。一般用于共享指针。和const类似，也分为指向volatile变量的指针，和volatile指针，甄别方法同const

## assert断言

1. 若非真，则终止程序
2. 是**宏**而不是函数
3. 可以定义`NDEBUG`来关闭，但要在`#include<cassert>`之前

```cpp
#define NDEBUG          // 加上这行，则assert不可用
#include <cassert>
assert( p != NULL );
```

## sizeof

1. sizeof(数组) = 整个数组所占空间
2. sizeof(指针) = 指针本身所占空间

## #pragma pack(n)

```cpp
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设为4字节对齐

struct test
{
    ...
};

#pragma pack(pop)   // 恢复对齐状态
```

## 位域

1. 类中可将成员变量定义为位域，形式位`type [member_name] : width ;`
2. 一个位域含指定数量的二进制位
3. 内存分布与机器有关
4. 类型必须是`int`/`unsigned int`/`signed int`
5. 取地址符&不能作用于位域；任何指针无法指向位域

```cpp
struct test
{
    unsigned a : 1;
    unsigned : 4;   // 空域
    unsigned b : 3; // 从下一单元开始存放
} x;
x.a = 1;
x.b = 5;
x.b = ~x.b; // 2
printf("%d %d\n", x.a, x.b);
```

## extern "C"

1. 告知编译器，这部分代码按C语言方式编译和链接

```cpp
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

## struct在C与C++中区别

|                |       C        |                C++                |
| :------------: | :------------: | :-------------------------------: |
|  **成员函数**  |       ×        |                 √                 |
|  **静态成员**  |       ×        |                 √                 |
|  **可否继承**  |       ×        |                 √                 |
| **可否初始化** |       ×        |                 √                 |
|   **访问权**   | public，不可改 | 默认public，可改private/protected |

### C

```c
// 第一种
typedef struct Student {
    int age; 
} S;

// 第二种，与第一种等价
struct Student { 
    int age; 
};
typedef struct Student S;   // S与struct Student等价
void Student(){}    // 并不冲突，在C中Student与struct Student区分

// 第三种
struct { 
    int age; 
} student;  // 此处是变量而不是tag
```

### C++

```cpp
struct Student { 
    int age; 
};
void f(Student x){}  // 在C++中可用Student代替struct Student
void Student(){}   // 此后，Student只代表此函数，与struct Student区分
```

## struct与class在C++中区别

|                        |            struct             |   class    |
| :--------------------: | :---------------------------: | :--------: |
|        **本质**        |        数据结构实现体         | 对象实现体 |
|     **默认访问权**     |            public             |  private   |
|   **默认继承访问权**   |            public             |  private   |
|  **用于定义模板参数**  |               ×               |     √      |
| **可否用大括号初始化** | 仅无构造函数且成员全public时√ |     √      |

!> struct继承class或反过来时，默认继承访问权取决于子类而不是基类。可指明继承方式，如`class B : public A{}；`

## union联合

1. 有多个数据成员，但任意时刻只有一个数据成员有值
2. 某成员赋值后，其他成员变为未定义状态
3. 默认访问权为public
4. 可含有构造/析构函数
5. 不可含有引用类型的成员
6. 不可继承/被继承
7. 不可含有虚函数
8. **匿名union**
    1. 在定义所在作用域可直接访问union成员
    2. 包含protected成员或private成员
    3. 全局匿名union必须static

## explicit显式

1. 修饰**构造函数**，可防止隐式转换和复制初始化
2. 修饰**转换函数**，可防止隐式转换，但*按语境转换*除外

```cpp
struct B
{
    explicit B(int) {}
    explicit operator bool() const { return true; }
};
void doB(B b) {}
int main()
{
    B b1(1);        // OK：直接初始化
    B b2 = 1;       // 错误：被 explicit 修饰构造函数的对象不可以复制初始化
    B b3{ 1 };      // OK：直接列表初始化
    B b4 = { 1 };   // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
    B b5 = (B)1;    // OK：允许 static_cast 的显式转换
    doB(1);         // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b6(b1);    // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b7 = b1;   // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
    bool b8 = static_cast<bool>(b1);    // OK：static_cast 进行直接初始化

    return 0;
}
```

## friend友元

1. **分类**
    1. **友元函数**：声明在类内（加friend）、定义在类外、可直接访问类的私有成员的非成员函数

    !> 友元函数声明在公有、私有部分没有区别

    2. **友元类**：该类的所有成员函数都是另一个类的友元函数
2. **特点**
    1. 友元关系**不可继承**
    2. 友元关系**不可传递**
    3. 友元类的关系是**单向**的，不具有交换性
    4. 削弱封装性

## using

1. **using声明**：`using namespace_name::name;`。引入命名空间的一个成员
2. **using指示**：`using namespace namespace_name;`。引入命名空间的所有成员

## ::（范围解析运算符）

1. **全局作用域符**`::name`
2. **类作用域符**`class_name::name`
3. **命名空间作用域符**`namespace_name::name`

## enum枚举量

1. **定义**:`enum [enumeration name] {enumerator1[=value1], enumerator2[=value2], ...};`
2. **枚举量的类型和取值**：整数。默认第一个枚举量赋值0，其他枚举量取值是前一个取值+1
3. **运算**：只有赋值运算，没有算术运算
4. **赋值**：只能赋值为枚举量符号，而不是整数值
5. **范围**（略）
6. **强枚举类型enum class（C++11）**（略）

## decltype（C++11）

1. `decltype ( expression )`，等价于表达式的数据类型

## 面向对象

### 封装（三种访问控制权）

|                      | public | protected | private |
| :------------------: | :----: | :-------: | :-----: |
|   **对本类/友元**    |   √    |     √     |    √    |
|      **对子类**      |   √    |     √     |    ×    |
| **对外部（调用方）** |   √    |     ×     |    ×    |

### 继承

1. **基类（父类）→ 派生类（子类）**
2. **构造/析构函数调用顺序**
    1. **构造函数**：父类→成员→子类自己
    2. **析构函数**：子类自己→成员→父类
    3. 多继承时，调用顺序取决于书写顺序，但**虚继承的构造函数总是最优先**

!> 多继承`class A: public B1,B2,B3`等价于`class A: public B1, private B2, private B3`

### 多态（虚函数）

1. **定义**：信息以多种形式显示的能力
2. 以封装和继承为基础
3. **分类**（后面默认指第二种，即虚函数）

|      类型      |   表现时期    |             实现             |
| :------------: | :-----------: | :--------------------------: |
|  **重载多态**  |    编译期     |     函数重载、运算符重载     |
| **子类型多态** |    运行期     |            虚函数            |
|  **参数多态**  |    编译期     |       类模板、函数模板       |
|  **强制多态**  | 编译期/运行期 | 基本类型转换、自定义类型转换 |

!> 编译期表现的多态又叫**静态多态（早绑定）**，运行期表现的多态又叫**动态多态（晚绑定）**

4. **实现**：当类中存在虚函数时，编译器会在程序**只读数据段**自动生成和维护一个**虚函数表**，它存储着类成员函数指针。同时，编译器在类中生成一个指向虚函数表的指针vptr

!>父类的构造方法中调用虚函数，不会发生多态

5. **不能被声明为虚函数的函数**：普通函数（非成员函数）、static成员函数、inline成员函数、构造函数、友元函数
6. **虚析构函数**
    1. **目的**：防止内存泄漏。删除指向子类对象的基类指针时，可以调用子类的析构函数，达到释放子类中堆内存的目的

    ```cpp
    class Base                      // 基类
    {
    public:
        Base();                     // 构造函数不能是虚函数
        virtual void f();
        virtual ~Base();            // 虚析构函数
    };
    class Derived : public Base     // 派生类
    {
    public:
        virtual void f();
        ~Derived();
    };

    int main()
    {
        Base *x = new Derived();
        x->f();    
        delete x;  // 因为基类有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏；否则只调用基类析构函数
        x = NULL;
        return 0；
    }
    ```

7. **纯虚函数**：虚函数后加`=0`，如`virtual void f() = 0;`
    1. 虚函数在父类中声明并定义，纯虚函数在父类中仅声明
    2. 不带纯虚函数的类叫**普通类**，虚函数在子类中可以不重写；带纯虚函数的类叫**抽象类**，不能直接实例化，只有被继承并重写其虚函数后，才能使用
    3. *仅*含有纯虚函数的类叫**接口类**
    4. **聚合类**：所有成员public、没有构造函数、没有类内初始化、没有基类、没有virtual函数

    !> 抽象类也可以派生为抽象类

8. **虚继承**（TODO）

### C实现C++类

1. **封装**：使用函数指针把属性与方法封装到结构体中
2. **继承**：结构体嵌套
3. **多态**：父类与子类方法的函数指针不同

## 模板

1. **函数模板**：`template <typename T> void f(){...};`
2. **模板函数**：由函数模板生成的函数
3. **类模板**：专门产生类的模板`template <typename T> class A{...};`
4. **模板类**：由类模板生成的类，如`vector<int>`

## 内存分配和管理

1. **malloc**：`void* malloc (size_t size);`。申请指定字节数内存，初始值不确定
2. **calloc**：`void* calloc (size_t num, size_t size);`。分配容纳指定个数、指定长度的对象，初始置0
3. **realloc**：`void* realloc (void* ptr, size_t size);`。更改以前分配的内存长度（增/减）

!> 增加时，可能需要移到另一个足够大的区域，而新增区域初始值不确定

4. **alloca**：在**栈**上申请内存，程序出栈时自动释放

!> **不具可移植性**，且在没有传统堆栈的机器上很难实现，不宜使用在必须广泛移植的程序中。C99中支持变长数组(VLA)来替代

5. **free**：`void free (void* ptr);`。释放`malloc`/`calloc`/`realloc`申请的内存
6. **new/new[]** ：先底层调用`malloc`分配内存，再调用构造函数
    1. **定位new**：允许传递额外地址参数来指定内存区域。`place_address`是指针，`initializers`提供一个（可空）逗号分隔的初始值列表
    
    ```cpp
    new (place_address) type
    new (place_address) type (initializers)
    new (place_address) type [size]
    new (place_address) type [size] { braced initializer list }
    ```

7. **delete/delete[]** ：先调用析构函数，再底层调用`free`释放空间
    1. `delete this`**合法**，但要保证：
        1. this对象通过`new`分配（`new[]`也不行）
        2. 以后不再使用该对象

!> `new`和`delete`是保留字，不需要头文件；而`malloc`和`free`需要`<cstdlib>`

## 智能指针

1. **头文件**：`#include <memory>`
2. **作用**：对裸指针进行了包装，利用对象生命周期结束自动析构的特点，完成自动管理
3. **分类**
    1. **unique_ptr（C++11）**：独占式，一个对象和相应资源同时只被一个指针拥有。一旦拥有者销毁、变成empty或拥有另一对象，就销毁前一对象并清理相关资源
    2. **shared_ptr**：共享式，多个智能指针可共享同一对象。其中最后一个负责销毁对象并清理相关资源
    3. **weak_ptr**：允许共享但不拥有，一旦最后一个拥有该对象的智能指针失去所有权，任何weak_ptr都变成empty
    4. **auto_ptr（仅C++98）**

## 强制类型转换运算符

1. **static_cast**
    1. **用途**：非多态类型转换。常用于转换数值数据类型
    2. 不执行运行时类型检查（转换安全性不如dynamic_cast）
    3. 可以在整个类层次结构中移动指针。子类转化为父类安全（向上转换，隐式），反之不安全（因为子类可能有不在父类的字段或方法）
2. **dynamic_cast**
    1. **用途**：多态类型转换。只适用于指针或引用
    2. 执行行运行时类型检查
    3. 不明确指针转换将失败（返回nullptr），但不引发异常
    4. 可以在整个类层次结构中移动指针，包括向上转换、向下转换
3. **const_cast**
    1. **用途**：删除const、volatile和__unaligned特性
4. **reinterpret_cast**
    1. **用途**：位的简单重新解释
    2. 允许将任何指针转换为任何其他指针类型，也允许将任何整数类型转换为任何指针类型以及反向转换，滥用容易带来风险
5. bad_cast：由于强制转换为引用类型失败，`dynamic_cast`运算符引发的异常

## 运行时类型信息RTTI（TODO）

## 目标文件

1. **格式**：Windows PE `.obj`，Linux ELF `.o`
2. **结构**

    |           段            |    名称    |                                        功能                                        |
    | :---------------------: | :--------: | :--------------------------------------------------------------------------------: |
    |       File Header       |   文件头   | 整个文件的文件属性（是否可执行、静态链接或动态连接、入口地址、目标硬件、目标OS等） |
    |      .text section      |   代码段   |                                语句编译成的机器代码                                |
    |      .data section      |   数据段   |                          已初始化的全局变量和局部静态变量                          |
    |      .bss section       |   BSS段    |              未初始化的全局变量和局部静态变量（只预留位置，不占空间）              |
    |     .rodata section     | 只读数据段 |                                        常量                                        |
    |    .comment section     | 注释信息段 |                                   编译器版本信息                                   |
    | .note.GNU-stack section | 堆栈提示段 |                                                                                    |

## 内存泄露

1. **定义**：程序分配了一块内存，但已经不再持有引用这块内存的对象，导致无法回收、无法被其他进程使用。泄漏内存将在整个程序声明周期内都不可使用
2. **场景**
    1. malloc和free/new和delete未成对出现
    2. delet void*的指针，导致没有调用对象的析构函数
    3. 没有将基类的析构函数定义为虚函数，导致只调用了父类的析构函数

## 内存对齐（struct/class/union）

1. **原则**
    1. **数据成员对齐规则**：struct或union的数据成员，第一个offset为0，以后每个存储位置要从该成员大小或成员的子成员大小（只要该成员有子成员，如数组/struct等）的整倍开始
    2. **struct作为成员**：则struct成员存储位置要从其内部“最宽基本类型成员”的整倍地址开始(基本类型不包括struct/class/uinon)
    3. 结构体的**总大小**（sizeof）必须是其内部最大成员的"最宽基本类型成员"的整倍
    4. sizeof(union)，以里面size最大元素为union的size。因为在某一时刻，union只有一个成员真正存储于该地址
2. **原因**
    1. **平台原因（移植原因）**：某些硬件平台只能在某些地址处取特定类型的数据
    2. **性能原因**：为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存访问仅一次

## 快排实现

```cpp
struct Range {
  int start, end;
  Range(int s = 0, int e = 0) { start = s, end = e; }
};

template <typename T>
void quick_sort(T arr[], const int len) {
  if (len <= 0) return;
  Range r[len];
  int p = 0;
  r[p++] = Range(0, len - 1);
  while (p) {
    Range range = r[--p];
    if (range.start >= range.end) continue;
    T mid = arr[range.end];
    int left = range.start, right = range.end - 1;
    while (left < right) {
      while (arr[left] < mid && left < right) left++;
      while (arr[right] >= mid && left < right) right--;
      std::swap(arr[left], arr[right]);
    }
    if (arr[left] >= arr[range.end])
      std::swap(arr[left], arr[range.end]);
    else
      left++;
    r[p++] = Range(range.start, left - 1);
    r[p++] = Range(left + 1, range.end);
  }
}
```
